#!/bin/sh

############################################################
# bpc_restore
#
# Restores files from BackupPC backup
# Exit code is equal to errors occurred
#
# WS 20100219
############################################################
########## Changes ##########
# Errors are printed to stderr now
# WS 20110407
####


# If files are to restored to a different directory change prefix
# prefix=/tmp
prefix=

# If no version is given, we will use the most recent backup
version=

# Name of the client repository
client=localhost

# Mask for blanks in file names
# Change this if you have file names containing this string
mask='+$$+'

# Backup directory
backuppath="/backup/pc/${client}"
#backuppath="/backup/archive"

# BackupPC_zcat executable
ZCAT=/usr/share/BackupPC/bin/BackupPC_zcat

############################################################
filter="$*"
rc=0

arg=
backupdate=
f=
files=
source=
target=
x=

# Check for BackupPC_zcat executable
if [ ! -x $ZCAT ]; then
	echo "Error: Could not find BackupPC_zcat in `dirname $ZCAT`" 1>&2
	exit 1
fi

# Check if backup statistics exists
if [ ! -r ${backuppath}/backups ]; then
	echo "Error: Cold not open ${backuppath}/backups, does the backup directory exist and is readable?" 1>&2
	exit 1
fi

if [ "$version" == "" ]; then
	version=`tail -1 ${backuppath}/backups | awk '{print $1}'`
fi
backupdate=`tail -1 ${backuppath}/backups | awk '{print $4}'`
backupdate="`date -d @${backupdate} '+%d.%m.%Y %H:%M:%S'`"


usage () {
cat << END

`basename $0` restores files from the last backup to their original location
Wildcards need to be escaped, arguments ar not case-sensitive


Usage:   `basename $0` <filter>
Example: `basename $0` \*junk.msf \*thunderbird\*

END
}


## Here we go
# Build arguments for find
if [ $# -gt 0 ];then
	for x in $*; do
		if echo $x | grep / > /dev/null 2>&1; then
			x=`echo $x | sed 's/\//\/f/g'`
		fi
		if echo $x | grep ! > /dev/null 2>&1; then
			x=`echo $x | sed 's/!//g'`
			arg="${arg} ! -iwholename *${x}"
		else
			arg="${arg} -iwholename *${x}"
		fi
	done
else
	echo "Error: No filter expression" 1>&2
	usage
	exit 1
fi

# Give feedback
echo "Filter =  \"${filter}\""
echo "Version = $version from $backupdate"
if [ "$prefix" == "" ]; then
	echo "The files will be restored to their original directories"
else
	echo "The files won't be restored to their original directories but relative to $prefix"
fi

# Finding files and escaping blanks
#echo "Arguments = \"$arg\""

files=`find ${backuppath}/${version} -type f $arg | sed 's/ /'"$mask"'/g'`

if [ "$files" == "" ]; then
	echo "No files for filter \"${filter}\" found"
	exit 0
else
	echo "`echo $files | awk ' {print NF}'` files will be restored"
	echo "Would you like me to continue (y=continue p=print files only)?"
	read answer
	case $answer in
		y|Y)
			echo "Starting restore"
		;;
		p|P)
			echo "The following files are selected for restore:"
			for f in $files; do
				echo $f | awk -F'f%2f' '{print $2}' | sed 's/'"$mask"'/ /g;s/\/f/\//g'
			done
			exit 0
		;;
		*)
			echo "Restore canceled"
			exit 0
		;;
	esac

fi
#exit

for f in $files; do
	source="`echo $f | sed 's/'"$mask"'/ /g'`"
	echo "Source: $source"
	target="${prefix}`echo $f | awk -F'f%2f' '{print $2}' | sed 's/'"$mask"'/ /g;s/\/f/\//g'`"
	targetpath=`dirname "$target"`

	if [ ! -d "$targetpath" ]; then
		echo "Creating directory \"$targetpath\""
		mkdir -p "$targetpath"
	fi

	echo "Restoring $target"
	$ZCAT "$source" > "$target"

	if [ ! $? -eq 0 ]; then
		echo "Error: Could not restore $target" 1>&2
		rc=`expr $rc + 1`
	fi

	touch -r "$source" "$target"
done

exit $rc

# EOF
